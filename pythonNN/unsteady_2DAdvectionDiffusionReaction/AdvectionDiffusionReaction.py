#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
@POD based reduced order model
Used for solving the reduced-order equation generated by POD basis method
including POD-G   :: solve the equation with online Newton-like iteration method
          POD-NN  :: solve the equation with offline  NN trained only with sample points 
          POD-PINN:: solve the euuation with offline  NN trained with sample points and equation
For general use, the reduced equations are simplified as the following formulation:
          alpha' * A * alpha + B * alpha = f
          where A B C and f are all functions of design parameters
          
@ Customed problem
2D Advection diffusion convection in enclosed cavity:
    >  u_t -K*(u2_x2 + u2_y2) + Vx*u_x + Vy*u_y  +a0*u = F
    > where alpha = (K) in [0.05, 0.5]is design parameters
POD;
    > phi = {u}
    > phi = phi0 + V*lamda
Reduced order equations:
    >  u_Modes' * Eq = 0
    
Created on Wed Jan 13 21:25:38 2021

@author: wenqianchen
"""



import sys
sys.path.insert(0,'../tools')
sys.path.insert(0,'../tools/NNs')
sys.path.insert(0,'./NumSols')

from Solver import Geometry, a0
import numpy as np
import torch
from Normalization import Normalization

# Eqs parameters


# reproducible
#torch.manual_seed(1234)  
#np.random.seed(1234)

# parameters
pi           = 3.141592653589793
Nrefine      = 1     # temporal refinement for POD_G
NVAR         = 1     # the number of unknown variables: u

class CustomedEqs(Geometry):
    def __init__(self, PODdatafile, M):
        super(CustomedEqs, self).__init__()
        datas  = np.load(PODdatafile)
        # data for POD
        self.init         = datas['init']  # initial field, shape 1*1*Nx*Ny*Nv
        self.FieldShape   = tuple(datas['FieldShape']) # shape 2
        self.tgrid        = datas['tgrid'][:,None]             # shape Nt * 1
        self.Nt           = self.tgrid.shape[0]
        self.dt           = self.tgrid[1,0]-self.tgrid[0,0]
        self.Modes        = datas['Modes'][:,:M]       # shape Nd*M, wheere Nd = (Nx-1)(Ny-1)
        self.sigma        = datas['sigma']             # shape min(Nd,M)
        self.parameters   = datas['parameters']        # shape Np*Nt*3
        self.projections  = datas['projections'][:,:,:M]     # shape Np*Nt*M
        self.design_space = datas['design_space']      # shape 2*3
        self.M            = M

        # projections
        _, Mapping  = Normalization.Mapstatic(self.projections.reshape((-1,self.M)))
        self.proj_mean =  Mapping[0][None,:] 
        self.proj_std  =  Mapping[1][None,:] 
        
        self.prepareROM()
        self.closure = self.getClosure(self.parameters, self.projections)
        
    def prepareROM(self):
        # initial solution
        self.u0  = self.init[0,0,:,:,0]
        self.F   = self.Force(self.u0, 0)
        
        # compute T on y boundary to meet boundary condition dT_dy = 0
        TMx = self.dx[0::self.InteriorShape[0]+1,0::self.InteriorShape[1]+1]
        TMy = self.dy[0::self.InteriorShape[0]+1,0::self.InteriorShape[1]+1]
        self.invTMx = np.linalg.inv(TMx)
        self.invTMy = np.linalg.inv(TMy)
        self.LinearB, self.LinearC, self.SourceD = self.getLinear()
    
    def Mode2Field(self, Vec):
        u            = np.zeros(self.FieldShape)
        u[1:-1,1:-1] = np.reshape( Vec, self.InteriorShape)
        # compute T on y boundary to meet boundary condition dT_dy = 0
        u[1:-1,[0,-1]] = np.matmul( self.invTMy, -np.matmul( self.dy[[0,-1],1:-1],u[1:-1,1:-1].T ) ).T        
        u[[0,-1], :]   = np.matmul( self.invTMx, -np.matmul( self.dx[[0,-1],1:-1],u[1:-1,:] ) ) 
        return u
        
    def GetProjectionCoeff(self, Snapshots_V, tgrid):
        Np,Nt = Snapshots_V.shape[0:2]
        S_V            = Snapshots_V.copy()- self.init
        lamda_Projection = np.matmul( (S_V[:,:,1:-1,1:-1,:]).reshape((Np*Nt,-1)), self.Modes)\
                           .reshape((Np,Nt,self.M)) 
        return lamda_Projection
    
    def RecoverFullOrder(self,lamda_Projection,tgrid):
        Np, Nt = lamda_Projection.shape[0:2]
        FullOrder = np.zeros((Np, Nt, *self.FieldShape, 1))
        for i in range(Np):
            for j in range(Nt):
                Proj  = np.matmul(self.Modes, lamda_Projection[i,j,:][:,None]).squeeze()
                Proj  = self.Mode2Field(Proj)[:,:,None]+ self.init[0,0,:,:,:] 
                FullOrder[i,j,:,:,:] = Proj
        return FullOrder
    
    
    def getClosure(self, alpha, proj):
        # Compute residual
        Np,Nt,M= proj.shape
        rhs  = self.rhs(proj, alpha[:,:,-1:].reshape((-1,1)),alpha[:,:,:-1].reshape(-1,1)).reshape((-1, Nt, M))
        resi = np.zeros_like(proj)
        resi[:,1:,:] = (proj[:,1:,:] - proj[:,:-1,:])/self.dt +  rhs[:,1:,:]
        return resi
   
    def RbfInterpolate(self, alpha_p, Nt=None, useClosure=True):
        if Nt is None:
            Nt = self.Nt
        Np,M = alpha_p.shape[0], self.M
        
        # Normalization
        lb= self.design_space[0,:-1][None,:]
        ub= self.design_space[1,:-1][None,:]
        x0_normal = (self.parameters[:,0,:-1]-(ub+lb)/2)/(ub-lb)*2
        x_normal  = (alpha_p                 -(ub+lb)/2)/(ub-lb)*2    
        
        from scipy.interpolate import Rbf
        y = np.zeros((Np, Nt, M))
        if not useClosure:
            return y
        for iM in range(M):
            for jt in range(1,Nt):
                #print('%d,%d'%(iM,jt))
                y0 = self.closure[:,jt,iM]
                y_mean = np.mean(y0)
                y_std  = np.std(y0)
                y0_normal  = (y0 - y_mean)/y_std
                #print(y_mean,y_std)
                rbf      = Rbf(x0_normal[:,0], y0_normal,function='gaussian')
                y_normal = rbf(x_normal[:,0])
                y[:,jt,iM] = y_normal*y_std + y_mean
        return y    
    
    def getLinear(self):
        """0:10 namely first index is related to terms:    
           index  [                 0           1          2            3       4 ]
           terms  [           -[u_xx+u_yy]    Vx*u_x      Vy*u_y      a0*u     -F ]
           coeff  [                 K         cos(t)       sin(t)       1       1 ]
        """
        
        B    = np.zeros((4,self.M, self.M))
        C    = np.zeros((4,self.M))
        D    = np.zeros((1,self.M))
        
        u0           = self.u0
        u0xc,  u0yc  = self.Compute_d_d1(u0)
        u0xc2, u0yc2 = self.Compute_d_d2(u0)
        F =self.F
        for j in range(self.M):
            uj= self.Mode2Field(self.Modes[:,j])      
            ujxc, ujyc= self.Compute_d_d1(uj)
            ujxc2, ujyc2 = self.Compute_d_d2(uj)
            for i in range(self.M):
                ui = self.Mode2Field(self.Modes[:,i])
                B[0,i,j] =-( self.Interior*(  ujxc2*ui + ujyc2*ui ) ).sum()
                B[1,i,j] =+( self.Interior*(   ujxc*ui            ) ).sum()
                B[2,i,j] =+( self.Interior*(   ujyc*ui            ) ).sum()
                B[3,i,j] =+( self.Interior*(     uj*ui            ) ).sum()

                C[0,i]   =-( self.Interior*(  u0xc2*ui + u0yc2*ui ) ).sum()
                C[1,i]   =+( self.Interior*(   u0xc*ui            ) ).sum()
                C[2,i]   =+( self.Interior*(   u0yc*ui            ) ).sum()
                C[3,i]   =+( self.Interior*(     u0*ui            ) ).sum()

                D[0,i]   =-( self.Interior*(     F*ui            ) ).sum()
        return B,C,D
    
    def getCoef(self, alpha, cos=np.cos, sin=np.sin, sqrt=np.sqrt, cat=np.concatenate ):
        K    = alpha[:,0:1]
        t    = alpha[:,1:2]
        one  = t*0 + 1
        LinearCoeff  = cat((K, cos(t), sin(t), one*a0), axis=1)
        return LinearCoeff
    
    def rhs(self, lamda, t, alpha_p, matmul=np.matmul):
        lamda = lamda.reshape((-1, self.M))
        alpha = np.concatenate((alpha_p, np.array(t).reshape((-1,1))), axis=1)
        LinearCoeff=self.getCoef(alpha)
        B = (LinearCoeff[:,:,None,None] * self.LinearB[None,:,:,:]).sum(axis=1) 
        C = (LinearCoeff[:,:,None]      * self.LinearC[None,:,:]  ).sum(axis=1) \
           +(                              self.SourceD[None,:,:] ).sum(axis=1)
        #Bx
        fx   = matmul(B,lamda[:,:,None]).reshape(lamda.shape)
        # C
        fx   = fx + C
        return fx
    
    
    def POD_G(self,alpha_p,lamda0, useClosure=False, Nt=None):
        # AddClosure
        #     0: No closure
        #     1: RBF interpolated closure 
        if Nt is None:
            Nt = self.Nt
                
        
        Np = alpha_p.shape[0]   
        lamda  = np.zeros((Np, Nt,self.M))
        if Nt ==0:
            return lamda
        
        #from scipy.integrate import odeint
        
        
        if not useClosure:
            closure = np.zeros((Np,Nt,self.M))
        else:
            closure = self.RbfInterpolate(alpha_p, useClosure=useClosure, Nt=Nt)
            
        for i in range(Np):
            print('i=%d'%i)
            lamda[i,:,:] = self.CN(alpha_p[i:i+1,:], lamda0[i,:], closure[i,:,:], Nrefine=Nrefine,Nt=Nt)
            #lamda[i,:,:] = self.RK44(alpha_p[i:i+1,:], Nrefine=Nrefine)
#            res=odeint(lambda f, t: self.rhs(f,t,alpha_p[i:i+1,:]),\
#                       u0, tgrid_refine, full_output=1)
#            lamda[i,:,:] = res[0]
            #print(res[1])
            pass
            
        return lamda

    
    def CN(self,alpha_p,lamda0, closure, Nt, Nrefine=100): 
        from scipy.optimize import fsolve
        lamda  = np.zeros((Nt,self.M))
        lamda[0,:] =lamda0;
        h = self.dt / Nrefine        
        t0 = self.tgrid[0,0]
        L0 = lamda[0,:]
        for i in range(0, Nt-1):
            for j in range(Nrefine):
                #source = 0*self.rhs(L0,t0,alpha_p).squeeze() + L0/h
                rhs   = lambda L: L/h + self.rhs(L,t0+h,alpha_p).squeeze() - L0/h
                rhs_modify = lambda L: rhs(L) - closure[i+1,:]
                
                L     = fsolve( rhs_modify, L0)  
                #print('ij,%d,%d'%(i,j),'resi=',rhs_modify(L))
                
                L0 = L
                t0 = t0 + h
                
            lamda[i+1,:] =L
        return lamda
            
        
    
    def GetError(self,lamda, sol_V, Ncut=0):
        """
        alpha_p_V: n x 2
        lamda    : n x nt x M
        sol_V    : n x nt x nd
        """
        Np, Nt = lamda.shape[0:2]
        w = np.ones((Nt))*self.dt; w[[0,-1]] = w[[0,-1]] / 2
        sol_P =self.RecoverFullOrder(lamda, self.tgrid)
        diff = np.linalg.norm( (sol_P- sol_V)[:,:,1:-1,1:-1,:].reshape((Np,Nt,-1)), axis=2 )
        print('diff=\n',diff)        
        error       = np.sqrt( (diff[:,Ncut:]**2 *w[None,Ncut:]).sum(axis=1) )
        error       = error.mean() / (self.tgrid[-1,0]-self.tgrid[Ncut,0])
        return error
    
from NN import GeneralNet,DEVICE      



class CustomedNet(GeneralNet):
    def __init__(self, Ncut, layers=None,oldnetfile=None,roeqs=None, WeightLog=0):
        super(CustomedNet, self).__init__(layers=layers,OldNetfile=oldnetfile)
        self.WeightLog = WeightLog
        self.M = roeqs.M
        self.LinearB  = torch.tensor( roeqs.LinearB ).float().to(DEVICE)
        self.LinearC  = torch.tensor( roeqs.LinearC ).float().to(DEVICE)
        self.SourceD  = torch.tensor( roeqs.SourceD).float().to(DEVICE)
        self.lb   = torch.tensor(roeqs.design_space[0:1,:]).float().to(DEVICE)
        self.ub   = torch.tensor(roeqs.design_space[1:2,:]).float().to(DEVICE)
        self.lb[0,-1]  = torch.tensor(roeqs.tgrid[Ncut,0]).float().to(DEVICE)
        self.proj_std = torch.tensor( roeqs.proj_std ).float().to(DEVICE)
        self.proj_mean= torch.tensor( roeqs.proj_mean).float().to(DEVICE)
        self.roeqs    = roeqs
    
    def u_net_0(self,x):
        x = (x-(self.ub+self.lb)/2)/(self.ub-self.lb)*2
        alpha_p = x[:,:-1]
        t       = x[:,-1:]
        x0 = torch.cat((alpha_p,-torch.ones_like(t)),1)
        out = self.unet(x)-self.unet(x0)
        out = out*self.proj_std
        return out
    
    def u_net(self,x):
        x = (x-(self.ub+self.lb)/2)/(self.ub-self.lb)*2
        out = self.unet(x)
        out = out*self.proj_std + self.proj_mean
        return out
    
    def forward(self,x):
        return self.u_net(x).detach().cpu().numpy()
    
    def loss_NN(self, xlabel, ylabel):
        y_pred    = self.u_net(xlabel.view((-1,2)))
        diff      = (ylabel.view((-1,self.M))-y_pred)/self.proj_std
        loss_NN   = self.lossfun(diff,torch.zeros_like(diff))
        return loss_NN
    
    
    def loss_PINN(self,x):
        x        = x.view((-1,2))
        alpha_p  = x[:,:-1]
        t        = x[:,-1:]
        t.requires_grad_(True)
        alpha = torch.cat((alpha_p,t), axis=1)
        lamda = self.u_net( alpha )
        # lamda_mimus = self.u_net( torch.cat((alpha_p,t-self.dt), axis=1) )
        # dlamda = (lamda - lamda_mimus)/self.dt        
        dlamda=torch.zeros_like(lamda)
        for i in range(self.M):
            dlamda[:,i:i+1] = self.grad(lamda[:,i:i+1].sum(), t) 

        LinearCoeff= self.roeqs.getCoef(alpha, cos=torch.cos, sin=torch.sin, sqrt=torch.sqrt, cat=torch.cat )
        B = (LinearCoeff[:,:,None,None] * self.LinearB[None,:,:,:]).sum(axis=1) 
        C = (LinearCoeff[:,:,None]      * self.LinearC[None,:,:]  ).sum(axis=1) \
           +(                             self.SourceD[None,:,:] ).sum(axis=1) 
        #Bx
        fx   = torch.matmul(B,lamda[:,:,None]).view(lamda.shape)
        # C
        fx   = fx +C
        
        resi =dlamda+ fx
        
        
        return self.lossfun(resi,torch.zeros_like(resi))
    
    def loss_Hybrid(self, data_label, data_resi):
        return self.loss_NN(*data_label) + 10**self.WeightLog * self.loss_PINN(*data_resi)
    
        
if __name__ == '__main__':
    design_space = np.array([[0.05],[0.5]])   
    root='./NumSols/%0.2f_%0.2f'%( design_space[0,0],design_space[1,0] )

    file_POD_SVD = root  + '/'+'Snapshots_POD_SVD10.npz'
    M = 10
    roeqs = CustomedEqs(file_POD_SVD, M)
    print(roeqs.tgrid,'here')
    
    from plotting import newfig,savefig    
    import matplotlib.pyplot as plt
    SingularPlot = False
    if SingularPlot:
        newfig(width=0.8)
        plt.semilogy(np.arange(0,roeqs.sigma.shape[0],2)+1, roeqs.sigma[::2],'-k')
        plt.xlabel('$m$')
        plt.ylabel('Singular value')    
        plt.show()
        savefig('fig/SingularValues_%d'%(29))
#    
    CalculateError=True
    if CalculateError:
        file_Validation = root + '/' + 'Snapshots_Validation.npz'
        datas  = np.load(file_Validation)
        alpha  = datas['parameters']
        Np = alpha.shape[0]
        Nt = alpha.shape[1]
        Snapshots_V = datas['Snapshots'][0:Np,:,:,:,:]
        alpha_p= alpha[:,0, 0:1][0:Np,:]
        lamda_Projection = roeqs.GetProjectionCoeff(Snapshots_V, roeqs.tgrid)
        lamda_POD_G = roeqs.POD_G(alpha_p, lamda_Projection[:,0,:], useClosure=True)
        Error_projection = roeqs.GetError(lamda_Projection, Snapshots_V)
        Error_POD_G      = roeqs.GetError(lamda_POD_G     , Snapshots_V)
        print(Error_projection, Error_POD_G)



    DoValidate = False
    if DoValidate:
        file_Validation = root + '/' + 'Snapshots_POD.npz'
        datas  = np.load(file_Validation)
        alpha  = datas['parameters']
        Np = alpha.shape[0]
        Nt = alpha.shape[1]
        dt = roeqs.dt
        Snapshots_V = datas['Snapshots']
        lamda_Projection = roeqs.GetProjectionCoeff(Snapshots_V, roeqs.tgrid)
        #sol_P   = Snapshots_V
        sol_P   =roeqs.RecoverFullOrder(lamda_Projection, roeqs.tgrid)
        Error_P =roeqs.GetError(lamda_Projection, Snapshots_V)
        #sol_P = Snapshots_V
        ROM_error = np.zeros((Np,Nt))     
        ind_Mode = 0
        u_Mode = roeqs.Mode2Field(roeqs.Modes[:,ind_Mode])
        for ip in range(0,Np):
            for it in range(1,Nt):
                K=alpha[ip,it,0]
                t=alpha[ip,it,1]
                alpha_p = alpha[ip,it,:-1][None,:]
                Vx = np.cos(t)
                Vy = np.sin(t)

                uj = sol_P[ip,it,:,:,0]
                
                up = sol_P[ip,it-1,:,:,0]
                
                
                ujxc, ujyc   = roeqs.Compute_d_d1(uj)
                ujxc2, ujyc2 = roeqs.Compute_d_d2(uj)
                
                
                eq = (uj-up)/1/dt + Vx*ujxc+Vy*ujyc-K*(ujxc2+ujyc2) + a0* uj - roeqs.F
                eq =  eq*roeqs.Interior
                #print('%d: (%e, %e, %e, %e)'%(ind, abs(eq1).max(), abs(eq2).max(),abs(eq3).max(), abs(eq4).max(), ))
                print('%d,%d: (%e)'%(ip,it, np.sqrt((eq**2).mean()), ))
                ROM_errori = ( u_Mode*eq).sum() 
                print('ROM error: %e'%( ROM_errori) )
                #print('Projection error: %e'%Error_P)
                ROM_error[ip,it] = ROM_errori
        plt.figure(); plt.plot(roeqs.tgrid[1:,:],ROM_error[:,1:].T);plt.show()
        
    DoTestPODG = False
    if DoTestPODG:
        file_Validation = root + '/' + 'Snapshots_POD.npz'
        datas  = np.load(file_Validation)
        alpha  = datas['parameters']
        Np = alpha.shape[0]
        Nt = alpha.shape[1]
        M  = roeqs.M
        dt = roeqs.dt
        Snapshots_V = datas['Snapshots']
        lamda_Projection = roeqs.GetProjectionCoeff(Snapshots_V, roeqs.tgrid)
        ROM_residual = np.zeros((Np,Nt,M))   
        for ip in range(0,1):
            for it in range(1,Nt):
                alpha_p = alpha[ip,it,:-1][None,:]
                t=alpha[ip,it,-1:]
                
                lamda   = lamda_Projection[ip,it  ,:][None,:]
                lamda_p = lamda_Projection[ip,it-1,:][None,:]
                #lamda_m = lamda_Projection[ip,it+1,:][None,:]
                dlamda  = roeqs.rhs(lamda, t, alpha_p)
                
                resi =  (lamda  - lamda_p)/1/dt + dlamda
                # print('%d,%d'%(ip,it))
                # print(resi)
                ROM_residual[ip,it,:] = resi.squeeze()
                
        plt.figure(); plt.plot(roeqs.tgrid[1:,:],ROM_residual[0,1:,:]);plt.show()
        lamda_norm=(lamda_Projection[:,:,:].reshape((-1,roeqs.M))-roeqs.proj_mean)/roeqs.proj_std
        lamda_norm=lamda_norm.reshape((Np,Nt,M))[:,0:,5:10].transpose((1,0,2)).reshape((Nt-0,-1))
        plt.figure(); plt.plot(roeqs.tgrid[0:, 0],lamda_norm,'-*');plt.show()

        
