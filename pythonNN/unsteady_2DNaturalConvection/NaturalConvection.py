#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
@POD based reduced order model
Used for solving the reduced-order equation generated by POD basis method
including POD-G   :: solve the equation with online Newton-like iteration method
          POD-NN  :: solve the equation with offline  NN trained only with sample points 
          POD-PINN:: solve the euuation with offline  NN trained with sample points and equation
For general use, the reduced equations are simplified as the following formulation:
          alpha' * A * alpha + B * alpha = f
          where A B C and f are all functions of design parameters
          
@ Customed problem
2D Natural convection in enclosed cavity Problem:
    >  u_x + v_y = 0
    >  u_t+u*u_x + v*u_y = -p_x + sqrt(Pr/Ra)*(u2_x2 + u2_y2) + T*sinTh
    >  v_t+u*v_x + v*v_y = -p_y + sqrt(Pr/Ra)*(v2_x2 + v2_y2) + T*cosTh
    >  T_t+u*T_x + v*T_y = 1/sqrt(Pr*Ra)*(T2_x2 + T2_y2) 
    > where alpha = (Ra, Th) in [1E4, 3E4]x[5pi/12,pi/2] is design parameters
POD;
    > phi = {p,u,v,T}
    > phi = phi0 + V*lamda
Reduced order equations:
    > p_Modes' * Eq1 + u_Modes' * Eq2 +v_Modes' * Eq3 + T_Modes' * Eq4 = 0
    
Created on Wed May 4 21:25:38 2020

@author: wenqianchen
"""



import sys
sys.path.insert(0,'../tools')
sys.path.insert(0,'../tools/NNs')

from Chebyshev import Chebyshev2D
import numpy as np
import torch
from Normalization import Normalization

# Eqs parameters


# reproducible
#torch.manual_seed(1234)  
#np.random.seed(1234)

# parameters
pi           = 3.141592653589793
Nrefine      = 1 # temporal refinement for POD_G
NVAR         = 4     # the number of unknown variables: p,u,v,T
Amplitude    = 0.8
Periodic     = 10

class Geometry():
    def __init__(self):
        # problem descprition
        self.FieldShape   = [33, 33]
        
        # spatial discretization
        self.xCoef, self.yCoef = 1/2, 1/2
        self.Chby2D   = Chebyshev2D(xL=-1, xR=1, yD=-1, yU=1, Mx=self.FieldShape[0]-1,My=self.FieldShape[1]-1)
        self.dxp,self.dyp  = self.Chby2D.DxCoeffN2()
        self.dx, self.dy   = self.Chby2D.DxCoeff(1) 
        self.d2x, self.d2y = self.Chby2D.DxCoeff(2)
        self.xc,   self.yc   = self.Chby2D.grid()

        # Interior / boundary flag
        self.InteriorShape = (self.FieldShape[0]-2, self.FieldShape[1]-2,)
        self.Interior = np.zeros(self.FieldShape); self.Interior[1:-1,1:-1]=1
        self.Boundary = np.ones(self.FieldShape);  self.Boundary[1:-1,1:-1]=0      
        
        
        # Based on an assumption that phi_init satisfy Neumann boundary condition 
        # We only need to address the time-dependent dirichlet boundary condition for Temperature
        # Tbc =  f(t) - Tbc_init 
        self.TBC =np.zeros(self.FieldShape)
        self.TBC[0,:]=1;
        
        self.TBC = 0.5 * ( 1- self.xc )
        
    def getGrid(self,Theta):
        xp = self.xCoef*self.xc*np.cos(Theta) - self.yCoef*self.yc*np.sin(Theta)
        yp = self.xCoef*self.xc*np.sin(Theta) + self.yCoef*self.yc*np.cos(Theta)
        return xp,yp

    
    def Tfun(self,t,sin=np.sin):  # take care: rememeber to minus the initial solution 
        return 0.5+  Amplitude*sin(2*pi/Periodic*t)-0.5
    
    def dTfun(self,t,dt, sin=np.sin, cos=np.cos):
        return  2*pi/Periodic*Amplitude*cos(2*pi/Periodic*t)
        #return ( self.Tfun(t,sin=sin) - self.Tfun(t-dt,sin=sin) )/dt
class CustomedEqs(Geometry):
    def __init__(self, PODdatafile, M):
        super(CustomedEqs, self).__init__()
        datas  = np.load(PODdatafile)
        # data for POD
        self.init         = datas['init']  # initial field, shape 1*1*Nx*Ny*Nv
        self.FieldShape   = tuple(datas['FieldShape']) # shape 2
        self.tgrid        = datas['tgrid']             # shape Nt * 1
        self.Nt           = self.tgrid.shape[0]
        self.dt           = self.tgrid[1,0]-self.tgrid[0,0]
        self.Modes        = datas['Modes'][:,:M]       # shape Nd*M, wheere Nd = (Nx-1)(Ny-1)
        self.sigma        = datas['sigma']             # shape min(Nd,M)
        self.parameters   = datas['parameters']        # shape Np*Nt*3
        self.projections  = datas['projections'][:,:M].reshape((-1,self.Nt,M))       # shape Np*Nt*M
        self.design_space = datas['design_space']      # shape 2*3
        self.M            = M


        NP_Interior  = (self.FieldShape[0]-2) * (self.FieldShape[1]-2)
        w      = np.ones((NVAR*NP_Interior,1))
        w[0::NVAR, 0] *= 0 
        self.Mass = np.matmul( self.Modes.T, (w*self.Modes) )
        self.Mass_inv = np.linalg.inv(self.Mass)

        # projections
        _, Mapping  = Normalization.Mapstatic(self.projections.reshape((-1,self.M)))
        self.proj_mean =  Mapping[0][None,:] 
        self.proj_std  =  Mapping[1][None,:] 
        
        self.prepareROM()
        self.closure = self.getClosure(self.parameters, self.projections)
        
    def prepareROM(self):
        # initial solution
        self.p0  = self.init[0,0,:,:,0]
        self.u0  = self.init[0,0,:,:,1]
        self.v0  = self.init[0,0,:,:,2]
        self.T0  = self.init[0,0,:,:,3]
        
        # compute T on y boundary to meet boundary condition dT_dy = 0
        TM = self.dy[0::self.InteriorShape[0]+1,0::self.InteriorShape[1]+1]
        self.invTM = np.linalg.inv(TM)
        self.QuadA,   self.QuadB,   self.QuadC                   = self.getQuadratic()
        self.LinearB, self.LinearC, self.LinearCt, self.LinearDt = self.getLinear()
    
    def Mode2Field(self, Vec):
        p,u,v,T= np.zeros(self.FieldShape), np.zeros(self.FieldShape), np.zeros(self.FieldShape), np.zeros(self.FieldShape)
        p[1:-1,1:-1] = np.reshape( Vec[0::NVAR], self.InteriorShape)
        u[1:-1,1:-1] = np.reshape( Vec[1::NVAR], self.InteriorShape)
        v[1:-1,1:-1] = np.reshape( Vec[2::NVAR], self.InteriorShape)
        T[1:-1,1:-1] = np.reshape( Vec[3::NVAR], self.InteriorShape)
        # compute T on y boundary to meet boundary condition dT_dy = 0
        T[1:-1,[0,-1]] = np.matmul( self.invTM, -np.matmul( self.dy[[0,-1],1:-1],T[1:-1,1:-1].T ) ).T        
        return p,u,v,T
        
    def GetProjectionCoeff(self, Snapshots_V, tgrid):
        Np,Nt = Snapshots_V.shape[0:2]
        TBC  = self.TBC[None,None,:,:] * self.Tfun(tgrid[None,:,:,None], sin=np.sin)
        S_V            = Snapshots_V.copy()- self.init
        S_V[:,:,:,:,3] = S_V[:,:,:,:,3] - TBC 
        lamda_Projection = np.matmul( (S_V[:,:,1:-1,1:-1,:]).reshape((Np*Nt,-1)), self.Modes)\
                           .reshape((Np,Nt,self.M)) 
        return lamda_Projection
    def RecoverFullOrder(self,lamda_Projection,tgrid):
        Np, Nt = lamda_Projection.shape[0:2]
        FullOrder = np.zeros((Np, Nt, *self.FieldShape, 4))
        for i in range(Np):
            for j in range(Nt):
                Proj  = np.matmul(self.Modes, lamda_Projection[i,j,:][:,None]).squeeze()
                Proj  = np.stack(self.Mode2Field(Proj), axis=2)+ self.init[0,0,:,:,:] 
                Proj[:,:,3]  =  Proj[:,:,3] + self.TBC*self.Tfun(self.tgrid[j,0],sin=np.sin)
                FullOrder[i,j,:,:,:] = Proj
        return FullOrder
    
    
    def getClosure(self, alpha, proj):
        # Compute residual
        Np,Nt,M= proj.shape
        rhs  = self.rhs(proj, alpha[:,:,-1:].reshape((-1,1)),alpha[:,:,:-1].reshape(-1,2)).reshape((-1, Nt, M))
        resi = np.zeros_like(proj)
        resi[:,1:,:] = (proj[:,1:,:] - proj[:,:-1,:])/self.dt -  rhs[:,1:,:]
        resi         = np.matmul(resi.reshape((-1, M)), self.Mass.T).reshape((-1,Nt,M))
        return resi
   
    def RbfInterpolate(self, alpha_p, Nt=None, useClosure=True):
        if Nt is None:
            Nt = self.Nt
        Np,M = alpha_p.shape[0], self.M
        
        # Normalization
        lb= self.design_space[0,:-1][None,:]
        ub= self.design_space[1,:-1][None,:]
        x0_normal = (self.parameters[:,0,:-1]-(ub+lb)/2)/(ub-lb)*2
        x_normal  = (alpha_p                 -(ub+lb)/2)/(ub-lb)*2    
        
        from scipy.interpolate import Rbf
        y = np.zeros((Np, Nt, M))
        if not useClosure:
            return y
        for iM in range(M):
            for jt in range(1,Nt):
                #print('%d,%d'%(iM,jt))
                y0 = self.closure[:,jt,iM]
                y_mean = np.mean(y0)
                y_std  = np.std(y0)
                y0_normal  = (y0 - y_mean)/y_std
                #print(y_mean,y_std)
                rbf      = Rbf(x0_normal[:,0],x0_normal[:,1], y0_normal,function='gaussian')
                y_normal = rbf(x_normal[:,0],x_normal[:,1])
                y[:,jt,iM] = y_normal*y_std + y_mean
        return y    
    
    
    def Compute_d_dxc(self, phi):
        return np.matmul(self.dx,phi)/self.xCoef
    def Compute_d_dyc(self, phi):
        return np.matmul(self.dy, phi.T).T/self.yCoef
    def Compute_dp_dxc(self, phi):
        return np.matmul(self.dxp,phi)/self.xCoef
    def Compute_dp_dyc(self, phi):
        return np.matmul(self.dyp, phi.T).T/self.yCoef   
    def Compute_d_dxc2(self, phi):
        return self.Compute_d_dxc( self.Compute_d_dxc(phi) )
    def Compute_d_dyc2(self, phi):
        return self.Compute_d_dyc( self.Compute_d_dyc(phi) )
    def Compute_d_dxcyc(self, phi):
        return self.Compute_d_dyc( self.Compute_d_dxc(phi) )
    def Compute_d_d1(self, phi):
        return self.Compute_d_dxc(phi), self.Compute_d_dyc(phi)
    def Compute_d_d1p(self, phi):
        return self.Compute_dp_dxc(phi), self.Compute_dp_dyc(phi)
    def Compute_d_d2(self, phi):
        return self.Compute_d_dxc2(phi), self.Compute_d_dyc2(phi)
    
    # get A from the first mth modes
    def getQuadratic(self): 
        "phi = phi_0 + phi_BC + V*lamda"
        """0:3 namely first index is related to terms:
           index [                        0                         ]
           terms [ [uu_x+vu_y]   +   [uv_x+vv_y]  +   [uT_x+vT_y]   ]
           weight[                        1                         ]
           coeff [     u         ,        v       ,        T        ]
        """
        A  = np.zeros((self.M, self.M, self.M))
        B  = np.zeros((2,self.M, self.M))
        C  = np.zeros((2,self.M))
        TBCxc,TBCyc= self.Compute_d_d1(self.TBC)
        u0, v0, T0 = self.u0, self.v0, self.T0
        u0xc,  u0yc= self.Compute_d_d1(u0)
        v0xc,  v0yc= self.Compute_d_d1(v0)
        T0xc,  T0yc= self.Compute_d_d1(T0)

        for j in range(self.M):
            pj, uj, vj, Tj= self.Mode2Field(self.Modes[:,j])
            ujxc, ujyc= self.Compute_d_d1(uj)      
            vjxc, vjyc= self.Compute_d_d1(vj) 
            Tjxc, Tjyc= self.Compute_d_d1(Tj) 
            for k in range(self.M):
                pk, uk,vk,Tk= self.Mode2Field(self.Modes[:,k])
                for i in range(self.M):
                    pi, ui,vi,Ti = self.Mode2Field(self.Modes[:,i])
                    A[k,i,j]=    ( self.Interior*(ui*ujxc*uk + vi*ujyc*uk) ).sum() \
                                +( self.Interior*(ui*vjxc*vk + vi*vjyc*vk) ).sum() \
                                +( self.Interior*(ui*Tjxc*Tk + vi*Tjyc*Tk) ).sum()
                                
                    B[0,k,j] =   ( self.Interior*(uj*u0xc*uk + vj*u0yc*uk) ).sum() \
                                +( self.Interior*(uj*v0xc*vk + vj*v0yc*vk) ).sum() \
                                +( self.Interior*(uj*T0xc*Tk + vj*T0yc*Tk) ).sum()\
                             + \
                                 ( self.Interior*(u0*ujxc*uk + v0*ujyc*uk) ).sum() \
                                +( self.Interior*(u0*vjxc*vk + v0*vjyc*vk) ).sum() \
                                +( self.Interior*(u0*Tjxc*Tk + v0*Tjyc*Tk) ).sum()
                                
                    B[1,k,j] =   ( self.Interior*(uj*TBCxc*Tk + vj*TBCyc*Tk) ).sum() \
                                
                    C[0,k]   =   ( self.Interior*(u0*u0xc*uk + v0*u0yc*uk) ).sum() \
                                +( self.Interior*(u0*v0xc*vk + v0*v0yc*vk) ).sum() \
                                +( self.Interior*(u0*T0xc*Tk + v0*T0yc*Tk) ).sum()
                    C[1,k]   =   ( self.Interior*(u0*TBCxc*Tk + v0*TBCyc*Tk) ).sum()  
        return A,B,C
    
    def getLinear(self):
        """0:10 namely first index is related to terms:    
           index  [                 0                     1          2        3            4   ]
           terms  [    -[u_xx+u_yy] - [v_xx+v_yy]   -[T_xx+T_yy]    -T       -T       [u_x +v_y+p_x+p_y]]
           weight [          u      +      v              T          u        v         p  + p + u + v  ]
           coeff  [              sqrt(Pr/Ra)        1/sqrt(Pr*Ra) sin(Th)  cos(Th)         1   ]
        """
        
        B    = np.zeros((5,self.M, self.M))
        C    = np.zeros((5,self.M))
        Ct   = np.zeros((5,self.M))
        Dt   = np.zeros((1,self.M))
        
        TBC            = self.TBC
        TBCxc,   TBCyc = self.Compute_d_d1(self.TBC)     
        TBCxc2, TBCyc2 = self.Compute_d_d2(self.TBC)  
        p0, u0, v0, T0 = self.p0, self.u0, self.v0, self.T0
        p0xc,  p0yc= self.Compute_d_d1p(p0)
        u0xc,  u0yc= self.Compute_d_d1(u0)
        v0xc,  v0yc= self.Compute_d_d1(v0)
        T0xc,  T0yc= self.Compute_d_d1(T0)
        u0xc2, u0yc2 = self.Compute_d_d2(u0)
        v0xc2, v0yc2 = self.Compute_d_d2(v0)
        T0xc2, T0yc2 = self.Compute_d_d2(T0)
        for j in range(self.M):
            pj, uj, vj, Tj= self.Mode2Field(self.Modes[:,j])      
            ujxc, ujyc= self.Compute_d_d1(uj)
            vjxc, vjyc= self.Compute_d_d1(vj)
            Tjxc, Tjyc= self.Compute_d_d1(Tj)
            pjxc, pjyc= self.Compute_d_d1p(pj)
            ujxc2, ujyc2 = self.Compute_d_d2(uj)
            vjxc2, vjyc2 = self.Compute_d_d2(vj)
            Tjxc2, Tjyc2 = self.Compute_d_d2(Tj)
            for i in range(self.M):
                pi, ui,vi,Ti = self.Mode2Field(self.Modes[:,i])
                B[0,i,j] =-( self.Interior*(  ujxc2*ui + ujyc2*ui ) ).sum()\
                          -( self.Interior*(  vjxc2*vi + vjyc2*vi ) ).sum()
                B[1,i,j] =-( self.Interior*(  Tjxc2*Ti + Tjyc2*Ti ) ).sum()
                B[2,i,j] =-( self.Interior*(  Tj   *ui            ) ).sum()
                B[3,i,j] =-( self.Interior*(  Tj   *vi            ) ).sum()
                B[4,i,j] = ( self.Interior*(  ujxc*pi  +  vjyc*pi ) ).sum()\
                          +( self.Interior*(  pjxc*ui  +  pjyc*vi ) ).sum()

                C[0,i]   =-( self.Interior*(  u0xc2*ui + u0yc2*ui ) ).sum()\
                          -( self.Interior*(  v0xc2*vi + v0yc2*vi ) ).sum()
                C[1,i]   =-( self.Interior*(  T0xc2*Ti + T0yc2*Ti ) ).sum()
                C[2,i]   =-( self.Interior*(  T0   *ui            ) ).sum()
                C[3,i]   =-( self.Interior*(  T0   *vi            ) ).sum()
                C[4,i]   = ( self.Interior*(  u0xc*pi  +  v0yc*pi ) ).sum()\
                          +( self.Interior*(  p0xc*ui  +  p0yc*vi ) ).sum()

                Ct[0,i] = 0
                Ct[1,i] =-( self.Interior*(  TBCxc2*Ti + TBCyc2*Ti ) ).sum()
                Ct[2,i] =-( self.Interior*(  TBC   *ui            ) ).sum()
                Ct[3,i] =-( self.Interior*(  TBC   *vi            ) ).sum()
                Ct[4,i] = 0
                
                Dt[0,i] = ( self.Interior*(  TBC   *Ti            ) ).sum()
        return B,C,Ct,Dt
    
    def getCoef(self, alpha, dt, cos=np.cos, sin=np.sin, sqrt=np.sqrt, cat=np.concatenate ):
        Ra    = alpha[:,0:1]
        Pr    = 0.71
        #Pr    = alpha[:,1:2]
        one   = Ra*0 + 1
        Theta = alpha[:,1:2]/180*pi
        #Theta  = one * pi/2
        t     = alpha[:,2:3]
        ft_xmin = self.Tfun(t, sin=sin)
        QuadCoeff = cat( (one, ft_xmin,), axis =1 )
        LinearCoeff  = cat((sqrt(Pr/Ra), 1/sqrt(Pr*Ra), sin(Theta), cos(Theta), one), axis=1)
        LinearCoefft = LinearCoeff * ft_xmin
        DtCoefft     = self.dTfun(t,dt=dt, sin=sin, cos=cos)
        return QuadCoeff, LinearCoeff, LinearCoefft,DtCoefft
    
    def rhs(self, lamda, t, alpha_p, matmul=np.matmul):
        lamda = lamda.reshape((-1, self.M))
        alpha = np.concatenate((alpha_p, np.array(t).reshape((-1,1))), axis=1)
        QuadCoeff, LinearCoeff, LinearCoefft, DtCoefft= self.getCoef(alpha,self.dt)
        A = self.QuadA[None, :, :, :]
        B = (  QuadCoeff[:,:,None,None] * self.QuadB[  None,:,:,:]).sum(axis=1) \
           +(LinearCoeff[:,:,None,None] * self.LinearB[None,:,:,:]).sum(axis=1) 
        C = (  QuadCoeff[:,:,None]      * self.QuadC[None,:,:]    ).sum(axis=1) \
           +(LinearCoeff[:,:,None]      * self.LinearC[None,:,:]  ).sum(axis=1) \
           +(LinearCoefft[:,:,None]     * self.LinearCt[None,:,:] ).sum(axis=1) \
           +(DtCoefft[    :,:,None]     * self.LinearDt[None,:,:] ).sum(axis=1)
        #x^TAx
        #print(lamda)
        fx   = matmul(lamda[:,None,None,:], A)
        fx   = matmul(fx,lamda[:,None,:,None]).reshape(lamda.shape) 
        #Bx
        fx   = fx+ matmul(B,lamda[:,:,None]).reshape(lamda.shape)
        # C
        fx   = fx + C
        fx   = -fx
        
        fx   =  matmul( fx, self.Mass_inv.T )
        #print('lamda',lamda)
        return fx
    
    
    def POD_G(self,alpha_p,lamda0, useClosure=False, Nt=None):
        # AddClosure
        #     0: No closure
        #     1: RBF interpolated closure 
        if Nt is None:
            Nt = self.Nt
                
        
        Np = alpha_p.shape[0]   
        lamda  = np.zeros((Np, Nt,self.M))
        if Nt ==0:
            return lamda
        
        #from scipy.integrate import odeint
        
        
        if not useClosure:
            closure = np.zeros((Np,Nt,self.M))
        else:
            closure = self.RbfInterpolate(alpha_p, useClosure=useClosure, Nt=Nt)
            
        for i in range(Np):
            print('i=%d'%i)
            lamda[i,:,:] = self.CN(alpha_p[i:i+1,:], lamda0[i,:], closure[i,:,:], Nrefine=Nrefine,Nt=Nt)
            #lamda[i,:,:] = self.RK44(alpha_p[i:i+1,:], Nrefine=Nrefine)
#            res=odeint(lambda f, t: self.rhs(f,t,alpha_p[i:i+1,:]),\
#                       u0, tgrid_refine, full_output=1)
#            lamda[i,:,:] = res[0]
            #print(res[1])
            pass
            
        return lamda

    
    def CN(self,alpha_p,lamda0, closure, Nt, Nrefine=100): 
        from scipy.optimize import fsolve
        lamda  = np.zeros((Nt,self.M))
        lamda[0,:] =lamda0;
        h = self.dt / Nrefine        
        t0 = self.tgrid[0,0]
        L0 = lamda[0,:]
        closure = np.matmul(closure, self.Mass_inv.T)
        for i in range(0, Nt-1):
            for j in range(Nrefine):
                #source = 0*self.rhs(L0,t0,alpha_p).squeeze() + L0/h
                rhs   = lambda L: L/h - self.rhs(L,t0+h,alpha_p).squeeze() - L0/h
                rhs_modify = lambda L: rhs(L) - closure[i+1,:]
                
                L     = fsolve( rhs_modify, L0)  
                #print('ij,%d,%d'%(i,j),'resi=',rhs_modify(L))
                
                L0 = L
                t0 = t0 + h
                
            lamda[i+1,:] =L
        return lamda
            
        
    
    def GetError(self,lamda, sol_V, Ncut=0):
        """
        alpha_p_V: n x 2
        lamda    : n x nt x M
        sol_V    : n x nt x nd
        """
        Np, Nt = lamda.shape[0:2]
        w = np.ones((Nt))*self.dt; w[[0,-1]] = w[[0,-1]] / 2
        sol_P =self.RecoverFullOrder(lamda, self.tgrid)
        diff = np.linalg.norm( (sol_P- sol_V)[:,:,1:-1,1:-1,:].reshape((Np,Nt,-1)), axis=2 )
        print('diff=\n',diff)

        
        # import matplotlib.pyplot as plt
        # plt.figure()
        # # plt.plot(self.tgrid, sol_P[0,:,3:9,16,0],'g-*',\
        # #          self.tgrid, sol_V[0,:,3:9,16,0],'r-o')
        # plt.semilogy(self.tgrid[1:],diff[0:10,1:].T)
        
        error       = np.sqrt( (diff[:,Ncut:]**2 *w[None,Ncut:]).sum(axis=1) )
        error       = error.mean() / (self.tgrid[-1,0]-self.tgrid[Ncut,0])
        return error

from NN import GeneralNet,DEVICE      



class ROM_Residual_Net(GeneralNet):
    def __init__(self,layers=None,oldnetfile=None,roeqs=None):
        super(ROM_Residual_Net, self).__init__(layers=layers,OldNetfile=oldnetfile)
        mean      =  np.mean(roeqs.closure)
        std       =  np.std(roeqs.closure) 
        self.mean =  torch.tensor( mean ).float().to(DEVICE)
        self.std  =  torch.tensor( std ).float().to(DEVICE)
        
        self.ub = torch.tensor( roeqs.design_space[1:2,:] ).float().to(DEVICE)
        self.lb = torch.tensor( roeqs.design_space[0:1,:] ).float().to(DEVICE)
        
    def u_net(self,x):
        x = (x-(self.ub+self.lb)/2)/(self.ub-self.lb)*2
        out = self.unet(x)
        out = out*self.std + self.mean
        return out
    def loss_NN(self, xlabel, ylabel):
        y_pred    = self.u_net(xlabel)
        diff      = (ylabel-y_pred)/self.std
        loss_NN   = self.lossfun(diff,torch.zeros_like(diff))
        return loss_NN

class CustomedNet(GeneralNet):
    def __init__(self, Ncut, layers=None,oldnetfile=None,roeqs=None, WeightLog=0):
        super(CustomedNet, self).__init__(layers=layers,OldNetfile=oldnetfile)
        self.WeightLog = WeightLog
        self.M = roeqs.M
        self.Mass_T     = torch.tensor( roeqs.Mass.T ).float().to(DEVICE)
        self.Mass_inv_T = torch.tensor( roeqs.Mass_inv.T ).float().to(DEVICE)
        self.QuadA = torch.tensor( roeqs.QuadA ).float().to(DEVICE)
        self.QuadB = torch.tensor( roeqs.QuadB ).float().to(DEVICE)
        self.QuadC = torch.tensor( roeqs.QuadC ).float().to(DEVICE)
        self.LinearB  = torch.tensor( roeqs.LinearB ).float().to(DEVICE)
        self.LinearC  = torch.tensor( roeqs.LinearC ).float().to(DEVICE)
        self.LinearCt = torch.tensor( roeqs.LinearCt).float().to(DEVICE)
        self.LinearDt = torch.tensor( roeqs.LinearDt).float().to(DEVICE)
        self.lb   = torch.tensor(roeqs.design_space[0:1,:]).float().to(DEVICE)
        self.ub   = torch.tensor(roeqs.design_space[1:2,:]).float().to(DEVICE)
        self.lb[0,-1]  = torch.tensor(roeqs.tgrid[Ncut,0]).float().to(DEVICE)
        self.proj_std = torch.tensor( roeqs.proj_std ).float().to(DEVICE)
        self.proj_mean= torch.tensor( roeqs.proj_mean).float().to(DEVICE)
        self.roeqs    = roeqs
        self.dt    = torch.tensor( roeqs.dt ).float().to(DEVICE)
    
    def u_net_0(self,x):
        x = (x-(self.ub+self.lb)/2)/(self.ub-self.lb)*2
        alpha_p = x[:,:-1]
        t       = x[:,-1:]
        x0 = torch.cat((alpha_p,-torch.ones_like(t)),1)
        out = self.unet(x)-self.unet(x0)
        out = out*self.proj_std
        return out
    
    def u_net(self,x):
        x = (x-(self.ub+self.lb)/2)/(self.ub-self.lb)*2
        out = self.unet(x)
        out = out*self.proj_std + self.proj_mean
        return out
    
    def forward(self,x):
        return self.u_net(x).detach().cpu().numpy()
    
    def loss_NN(self, xlabel, ylabel):
        y_pred    = self.u_net(xlabel.view((-1,3)))
        diff      = (ylabel.view((-1,self.M))-y_pred)/self.proj_std
        loss_NN   = self.lossfun(diff,torch.zeros_like(diff))
        return loss_NN
    
    
    def loss_PINN(self,x):
        x        = x.view((-1,3))
        alpha_p  = x[:,:-1]
        t        = x[:,-1:]
        t.requires_grad_(True)
        alpha = torch.cat((alpha_p,t), axis=1)
        lamda = self.u_net( alpha )
        #lamda_mimus = self.u_net( torch.cat((alpha_p,t-self.dt), axis=1) )
        #dlamda = (lamda - lamda_mimus)/self.dt        
        dlamda=torch.zeros_like(lamda)
        for i in range(self.M):
            dlamda[:,i:i+1] = self.grad(lamda[:,i:i+1].sum(), t) 

        QuadCoeff, LinearCoeff, LinearCoefft, DtCoefft= self.roeqs.getCoef(alpha, dt=self.dt, cos=torch.cos, sin=torch.sin, sqrt=torch.sqrt, cat=torch.cat )
        A = self.QuadA[None, :, :, :]
        B = (  QuadCoeff[:,:,None,None] * self.QuadB[  None,:,:,:]).sum(axis=1) \
           +(LinearCoeff[:,:,None,None] * self.LinearB[None,:,:,:]).sum(axis=1) 
        C = (  QuadCoeff[:,:,None]      * self.QuadC[None,:,:]    ).sum(axis=1) \
           +(LinearCoeff[:,:,None]      * self.LinearC[None,:,:]  ).sum(axis=1) \
           +(LinearCoefft[:,:,None]     * self.LinearCt[None,:,:] ).sum(axis=1) \
           +(DtCoefft[    :,:,None]     * self.LinearDt[None,:,:] ).sum(axis=1) 
        #x^TAx
        fx   = torch.matmul(lamda[:,None,None,:], A)
        fx   = torch.matmul(fx,lamda[:,None,:,None]).view(lamda.shape) 
        #Bx
        fx   = fx+ torch.matmul(B,lamda[:,:,None]).view(lamda.shape)
        # C
        fx   = fx +C
        
        # resi
        #resi =dlamda + torch.matmul( fx, self.Mass_inv_T )
        
        resi =torch.matmul( dlamda, self.Mass_T ) + fx
        
        
        return self.lossfun(resi,torch.zeros_like(resi))
    
    def loss_Hybrid(self, data_label, data_resi):
        return self.loss_NN(*data_label) + 10** self.WeightLog * self.loss_PINN(*data_resi)
    
        
if __name__ == '__main__':
    design_space = np.array([[1E4,75],[3E4,90]])   
    root='../NumSols/' + '%0.0E_%0.0Eand%0.1d_%0.1d'%(design_space[0,0],design_space[1,0], \
                                             design_space[0,1],design_space[1,1], \
                                             )
    #root = root + "__refine"
    #root = 'NumSols/' + 'test_No_ACM'
    file_POD_SVD = root  + '/'+'Snapshots_POD_SVD60.npz'
    M = 30
    roeqs = CustomedEqs(file_POD_SVD, M)
    
    from plotting import newfig,savefig    
    import matplotlib.pyplot as plt
    SingularPlot = False
    if SingularPlot:
        newfig(width=0.8)
        plt.semilogy(np.arange(0,roeqs.sigma.shape[0],2)+1, roeqs.sigma[::2],'-k')
        plt.xlabel('$m$')
        plt.ylabel('Singular value')    
        plt.show()
        savefig('fig/SingularValues_%d'%(29))
#    
    CalculateError=False
    if CalculateError:
        file_Validation = root + '/' + 'Snapshots_Validation.npz'
        datas  = np.load(file_Validation)
        alpha  = datas['parameters']
        Np = alpha.shape[0]
        Nt = alpha.shape[1]
        Snapshots_V = datas['Snapshots'][0:Np,:,:,:,:]
        alpha_p= alpha[:,0, 0:2][0:Np,:]
        lamda_Projection = roeqs.GetProjectionCoeff(Snapshots_V, roeqs.tgrid)
        lamda_POD_G = roeqs.POD_G(alpha_p, lamda_Projection[:,0,:], useClosure=True)
        Error_projection = roeqs.GetError(lamda_Projection, Snapshots_V)
        Error_POD_G      = roeqs.GetError(lamda_POD_G     , Snapshots_V)
        print(Error_projection, Error_POD_G)



    DoValidate =True
    if DoValidate:
        file_Validation = root + '/' + 'Snapshots_POD.npz'
        datas  = np.load(file_Validation)
        alpha  = datas['parameters']
        Np = alpha.shape[0]
        Nt = alpha.shape[1]
        dt = roeqs.dt
        Snapshots_V = datas['Snapshots']
        lamda_Projection = roeqs.GetProjectionCoeff(Snapshots_V, roeqs.tgrid)
        #sol_P   = Snapshots_V
        sol_P   =roeqs.RecoverFullOrder(lamda_Projection, roeqs.tgrid)
        Error_P =roeqs.GetError(lamda_Projection, Snapshots_V)
        print("Error_P",Error_P)
        #sol_P = Snapshots_V
        ROM_error = np.zeros((Np,Nt))     
        ind_Mode = 0
        p_Mode, u_Mode, v_Mode,T_Mode  = roeqs.Mode2Field(roeqs.Modes[:,ind_Mode])
        for ip in range(0,1):
            for it in range(1,Nt):
                Ra=alpha[ip,it,0]
                Pr=0.71
                #Pr=alpha[ip,it,1]
                Theta=alpha[ip,it,1]/180*np.pi
                t=alpha[ip,it,2]
                alpha_p = alpha[ip,it,:-1][None,:]
        #        Vec = roeqs.ExtractInteriorSnapshots(roeqs.Samples[:,ind:ind+1]).squeeze()
        #        pj,uj,vj,Tj = roeqs.Mode2Field(Vec)
        #        Tj = Tj + roeqs.TBC
                
                pj = sol_P[ip,it,:,:,0]
                uj = sol_P[ip,it,:,:,1]
                vj = sol_P[ip,it,:,:,2]
                Tj = sol_P[ip,it,:,:,3]
                
                up = sol_P[ip,it-1,:,:,1]
                vp = sol_P[ip,it-1,:,:,2]
                Tp = sol_P[ip,it-1,:,:,3]
                
                
                ujxc, ujyc= roeqs.Compute_d_d1(uj)
                vjxc, vjyc= roeqs.Compute_d_d1(vj)
                Tjxc, Tjyc= roeqs.Compute_d_d1(Tj)
                pjxc, pjyc= roeqs.Compute_d_d1p(pj)
                ujxc2, ujyc2 = roeqs.Compute_d_d2(uj)
                vjxc2, vjyc2 = roeqs.Compute_d_d2(vj)
                Tjxc2, Tjyc2 = roeqs.Compute_d_d2(Tj)
                
                
                # rhs = roeqs.rhs(lamda_Projection[ip,it,:],t,alpha_p)
                # rhs = np.matmul( rhs, roeqs.Mass.T )
                
                eq1 = (ujxc + vjyc) 
                eq2 = (uj-up)/1/dt + uj*ujxc+vj*ujyc+pjxc-np.sqrt(Pr/Ra)*(ujxc2+ujyc2)-Tj*np.sin(Theta)
                eq3 = (vj-vp)/1/dt + uj*vjxc+vj*vjyc+pjyc-np.sqrt(Pr/Ra)*(vjxc2+vjyc2)-Tj*np.cos(Theta)
                eq4 = (Tj-Tp)/1/dt + uj*Tjxc+vj*Tjyc     -1/np.sqrt(Pr*Ra)*(Tjxc2+Tjyc2)
                eq1 =  eq1*roeqs.Interior
                eq2 =  eq2*roeqs.Interior
                eq3 =  eq3*roeqs.Interior
                eq4 =  eq4*roeqs.Interior
                #print('%d: (%e, %e, %e, %e)'%(ind, abs(eq1).max(), abs(eq2).max(),abs(eq3).max(), abs(eq4).max(), ))
                print('%d,%d: (%e, %e, %e, %e)'%(ip,it, np.sqrt((eq1**2).mean()),\
                                                        np.sqrt((eq2**2).mean()),\
                                                        np.sqrt((eq3**2).mean()),\
                                                        np.sqrt((eq4**2).mean()), ))
                ROM_errori =            ( p_Mode*eq1).sum() \
                                      +( u_Mode*eq2).sum() \
                                      +( v_Mode*eq3).sum() \
                                      +( T_Mode*eq4).sum() 
                print('ROM error: %e'%( ROM_errori) )
                #print('Projection error: %e'%Error_P)
                ROM_error[ip,it] = ROM_errori
        plt.figure(); plt.plot(roeqs.tgrid[1:,:],ROM_error[:,1:].T);plt.show()
    DoTestPODG = False
    if DoTestPODG:
        file_Validation = root + '/' + 'Snapshots_POD.npz'
        datas  = np.load(file_Validation)
        alpha  = datas['parameters']
        Np = alpha.shape[0]
        Nt = alpha.shape[1]
        M  = roeqs.M
        dt = roeqs.dt
        Snapshots_V = datas['Snapshots']
        lamda_Projection = roeqs.GetProjectionCoeff(Snapshots_V, roeqs.tgrid)
        ROM_residual = np.zeros((Np,Nt,M))   
        for ip in range(0,1):
            for it in range(1,Nt):
                alpha_p = alpha[ip,it,0:2][None,:]
                t=alpha[ip,it,2]
                
                lamda   = lamda_Projection[ip,it  ,:][None,:]
                lamda_p = lamda_Projection[ip,it-1,:][None,:]
                #lamda_m = lamda_Projection[ip,it+1,:][None,:]
                dlamda  = roeqs.rhs(lamda, t, alpha_p)
                
                resi = np.matmul( (lamda  - lamda_p)/1/dt- dlamda, roeqs.Mass.T )
                # print('%d,%d'%(ip,it))
                # print(resi)
                ROM_residual[ip,it,:] = resi.squeeze()
                
        plt.figure(); plt.plot(roeqs.tgrid[1:,:],ROM_residual[0,1:,:]);plt.show()
        lamda_norm=(lamda_Projection[:,:,:].reshape((-1,roeqs.M))-roeqs.proj_mean)/roeqs.proj_std
        lamda_norm=lamda_norm.reshape((Np,Nt,M))[:,0:,5:10].transpose((1,0,2)).reshape((Nt-0,-1))
        plt.figure(); plt.plot(roeqs.tgrid[0:, 0],lamda_norm,'-*');plt.show()

        
